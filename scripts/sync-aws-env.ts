#!/usr/bin/env node

/**
 * Sync AWS CloudFormation outputs into local .env files so the frontend
 * and backend can talk to live infrastructure without manual copy/paste.
 *
 * Usage:
 *   npm run sync:aws:env -- --env=dev --region=us-east-1
 *   npm run sync:aws:env -- --stack=CustomStack --frontend=.env.local
 */

import { CloudFormationClient, DescribeStacksCommand } from '@aws-sdk/client-cloudformation'
import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

interface CliOptions {
  env?: string
  stack?: string
  region?: string
  frontend?: string
  backend?: string
  'dry-run'?: boolean
  dryRun?: boolean
}

type StackOutputs = Record<string, string>

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

const args = parseArgs(process.argv.slice(2))

const env = args.env || process.env.JOBDOCK_ENV || 'dev'
const stackName = args.stack || `JobDockStack-${env}`
const region =
  args.region || process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || 'us-east-1'
const frontendEnvPath = path.resolve(projectRoot, args.frontend || '.env')
const backendEnvPath = path.resolve(projectRoot, args.backend || path.join('backend', '.env'))
const dryRun = Boolean(args['dry-run'] ?? args.dryRun)

async function main() {
  const client = new CloudFormationClient({ region })
  const outputs = await getStackOutputs(client, stackName)

  if (!outputs.ApiUrl) {
    throw new Error(
      `Stack "${stackName}" does not expose ApiUrl output. Did you deploy the infrastructure?`
    )
  }

  const frontendEnv = buildFrontendEnv(outputs, {
    region,
    env,
  })
  const backendEnv = buildBackendEnv(outputs, {
    region,
    env,
  })

  if (dryRun) {
    console.log('--- Frontend .env preview ---')
    console.log(frontendEnv)
    console.log('--- Backend .env preview ---')
    console.log(backendEnv)
    return
  }

  await writeEnvFile(frontendEnvPath, frontendEnv)
  await writeEnvFile(backendEnvPath, backendEnv)

  console.log(`✅ Synced AWS outputs from stack "${stackName}" (${region})`)
  console.log(`   ↳ Frontend env: ${path.relative(projectRoot, frontendEnvPath)}`)
  console.log(`   ↳ Backend env: ${path.relative(projectRoot, backendEnvPath)}`)
  console.log('Tip: restart dev servers so new environment variables take effect.')
}

main().catch((error) => {
  console.error('Failed to sync AWS environment variables:', error instanceof Error ? error.message : error)
  process.exit(1)
})

function parseArgs(argv: string[]): CliOptions {
  const options: CliOptions = {}
  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i]
    if (!arg.startsWith('--')) continue
    const hasEquals = arg.includes('=')
    if (hasEquals) {
      const [key, value] = arg.slice(2).split('=')
      if (!key) continue
      ;(options as Record<string, string | boolean>)[key] = value ?? true
      continue
    }
    const key = arg.slice(2)
    const next = argv[i + 1]
    if (next && !next.startsWith('--')) {
      ;(options as Record<string, string | boolean>)[key] = next
      i++
    } else {
      ;(options as Record<string, string | boolean>)[key] = true
    }
  }
  return options
}

async function getStackOutputs(client: CloudFormationClient, stackName: string) {
  const command = new DescribeStacksCommand({ StackName: stackName })
  const result = await client.send(command)
  const stack = result.Stacks?.[0]
  if (!stack) {
    throw new Error(`Unable to find stack "${stackName}" in region ${region}`)
  }

  const outputs: StackOutputs = {}
  for (const output of stack.Outputs ?? []) {
    if (output.OutputKey && output.OutputValue) {
      outputs[output.OutputKey] = output.OutputValue
    }
  }

  return outputs
}

function buildFrontendEnv(outputs: StackOutputs, meta: { region: string; env: string }) {
  const apiUrl = sanitizeUrl(outputs.ApiUrl)
  return [
    `# Auto-generated by scripts/sync-aws-env.ts on ${new Date().toISOString()}`,
    `VITE_USE_MOCK_DATA=false`,
    `VITE_API_URL=${apiUrl}`,
    `VITE_AWS_REGION=${meta.region}`,
    `VITE_COGNITO_USER_POOL_ID=${outputs.UserPoolId ?? ''}`,
    `VITE_COGNITO_CLIENT_ID=${outputs.UserPoolClientId ?? ''}`,
    `VITE_S3_BUCKET=${outputs.FilesBucketName ?? ''}`,
    `VITE_DEFAULT_TENANT_ID=${process.env.VITE_DEFAULT_TENANT_ID || 'demo-tenant'}`,
  ].join('\n')
}

function buildBackendEnv(outputs: StackOutputs, meta: { region: string; env: string }) {
  return [
    `# Auto-generated by scripts/sync-aws-env.ts on ${new Date().toISOString()}`,
    `AWS_REGION=${meta.region}`,
    `ENVIRONMENT=${meta.env}`,
    `DATABASE_NAME=jobdock`,
    `DATABASE_ENDPOINT=${outputs.DatabaseEndpoint ?? ''}`,
    `DATABASE_SECRET_ARN=${outputs.DatabaseSecretArn ?? ''}`,
    `USER_POOL_ID=${outputs.UserPoolId ?? ''}`,
    `USER_POOL_CLIENT_ID=${outputs.UserPoolClientId ?? ''}`,
    `FILES_BUCKET=${outputs.FilesBucketName ?? ''}`,
    `DEFAULT_TENANT_ID=${process.env.VITE_DEFAULT_TENANT_ID || 'demo-tenant'}`,
  ].join('\n')
}

async function writeEnvFile(targetPath: string, contents: string) {
  await fs.mkdir(path.dirname(targetPath), { recursive: true })
  await fs.writeFile(targetPath, `${contents}\n`, 'utf8')
}

function sanitizeUrl(url: string) {
  if (!url) return ''
  return url.endsWith('/') ? url.slice(0, -1) : url
}

